"""
Arcania Vault Backend Server
Uses Flask, Flask-SQLAlchemy, and Flask-CORS to provide a zero-knowledge
API backend for the Arcania password manager.
"""

from flask import Flask, jsonify, request, abort
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
import hmac
import json
import os

# --- App Configuration ---
app = Flask(__name__)
CORS(app)  # Enable Cross-Origin Resource Sharing for the frontend

# Database Configuration (using SQLite in the instance folder)
basedir = os.path.abspath(os.path.dirname(__file__))
instance_path = os.path.join(basedir, 'instance')
if not os.path.exists(instance_path):
    os.makedirs(instance_path)

app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{os.path.join(instance_path, "arcania.db")}'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)

# --- Database Models ---

class User(db.Model):
    """
    User model to store account info.
    We NEVER store the Master Password. We only store hashes for verification.
    The vault data remains fully encrypted, and the key never leaves the client.
    """
    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(255), unique=True, nullable=False)
    
    # Salts generated by the client
    auth_salt = db.Column(db.String(255), nullable=False)
    encryption_salt = db.Column(db.String(255), nullable=False)
    
    # Hash of the *Account Password* (for login)
    auth_hash = db.Column(db.String(255), nullable=False)
    
    # Hash of the *Master Password* (for the unlock-vault check)
    master_password_check_hash = db.Column(db.String(255), nullable=False)
    
    # The entire encrypted vault, stored as a single JSON text blob.
    encrypted_vault_data = db.Column(db.Text, nullable=True, default='[]')

    def __repr__(self):
        return f'<User {self.email}>'

# --- API Endpoints ---

@app.route('/api/signup', methods=['POST'])
def signup():
    """
    Create a new user. Data is provided by the client's auth.js.
    """
    data = request.json
    if not all(k in data for k in ['email', 'authSalt', 'encryptionSalt', 'authHash', 'masterPasswordCheckHash']):
        return jsonify({"error": "Missing required fields"}), 400

    # Check if email already exists
    if User.query.filter_by(email=data['email']).first():
        return jsonify({"error": "An account with this email already exists."}), 409

    new_user = User(
        email=data['email'],
        auth_salt=data['authSalt'],
        encryption_salt=data['encryptionSalt'],
        auth_hash=data['authHash'],
        master_password_check_hash=data['masterPasswordCheckHash'],
        encrypted_vault_data='[]'  # Start with an empty vault
    )
    
    try:
        db.session.add(new_user)
        db.session.commit()
        return jsonify({"message": "Signup successful!"}), 201
    except Exception as e:
        db.session.rollback()
        return jsonify({"error": f"Database error: {str(e)}"}), 500

@app.route('/api/get-salts/<email>', methods=['GET'])
def get_salts(email):
    """
    Provides the auth salt for a user trying to log in.
    """
    user = User.query.filter_by(email=email).first()
    if not user:
        return jsonify({"error": "User not found."}), 404
    
    return jsonify({"authSalt": user.auth_salt}), 200

@app.route('/api/login', methods=['POST'])
def login():
    """
    Verifies the client-derived auth hash against the stored auth hash.
    This is for the main site login, not the vault unlock.
    """
    data = request.json
    if not all(k in data for k in ['email', 'providedAuthHash']):
        return jsonify({"error": "Missing email or hash"}), 400

    user = User.query.filter_by(email=data['email']).first()
    if not user:
        return jsonify({"error": "Invalid email or password."}), 401

    # Securely compare the client-provided hash with the stored hash
    try:
        is_valid = hmac.compare_digest(data['providedAuthHash'], user.auth_hash)
    except Exception:
        is_valid = False

    if is_valid:
        return jsonify({"message": "Login successful"}), 200
    else:
        return jsonify({"error": "Invalid email or password."}), 401

@app.route('/api/get-unlock-data/<email>', methods=['GET'])
def get_unlock_data(email):
    """
    Provides the data needed by the client to perform the zero-knowledge
    master password check.
    """
    user = User.query.filter_by(email=email).first()
    if not user:
        return jsonify({"error": "User not found."}), 404
        
    return jsonify({
        "encryptionSalt": user.encryption_salt,
        "masterPasswordCheckHash": user.master_password_check_hash
    }), 200

@app.route('/api/get-vault/<email>', methods=['GET'])
def get_vault(email):
    """
    Returns the user's complete encrypted vault data blob.
    """
    user = User.query.filter_by(email=email).first()
    if not user:
        return jsonify({"error": "User not found."}), 404
        
    # Send the raw text blob (which is a JSON string of an array)
    return jsonify(json.loads(user.encrypted_vault_data or '[]')), 200

@app.route('/api/save-vault/<email>', methods=['POST'])
def save_vault(email):
    """
    Receives the NEW complete encrypted vault blob from the client and overwrites
    the old one in the database.
    """
    user = User.query.filter_by(email=email).first()
    if not user:
        return jsonify({"error": "User not found."}), 404

    # The client sends the encrypted array as the request's JSON body
    encrypted_data_array = request.json
    
    # Store it as a JSON string in the database
    user.encrypted_vault_data = json.dumps(encrypted_data_array)
    
    try:
        db.session.commit()
        return jsonify({"message": "Vault saved successfully"}), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({"error": f"Database error: {str(e)}"}), 500

@app.route('/api/delete-account', methods=['POST'])
def delete_account():
    """
    Permanently deletes a user and all their data from the database.
    """
    data = request.json
    email = data.get('email')
    if not email:
        return jsonify({"error": "Email is required"}), 400

    user = User.query.filter_by(email=email).first()
    if not user:
        return jsonify({"error": "User not found."}), 404

    try:
        db.session.delete(user)
        db.session.commit()
        return jsonify({"message": "Account successfully deleted"}), 200
    except Exception as e:
        db.session.rollback()
        return jsonify({"error": f"Database error: {str(e)}"}), 500

# --- Main Entry Point ---
if __name__ == '__main__':
    with app.app_context():
        db.create_all()  # Create database tables if they don't exist
    app.run(debug=True, port=5000)